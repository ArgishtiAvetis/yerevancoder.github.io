{"version":3,"sources":["webpack:///path---2017-12-31-elm-intro-2d0df19cf43fb9f3344a.js","webpack:///./.cache/json/2017-12-31-elm-intro.json"],"names":["webpackJsonp","496","module","exports","data","site","siteMetadata","title","author","markdownRemark","id","html","frontmatter","date","discussionId","pathContext","slug"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,cAAgBC,MAAA,eAAAC,OAAA,sBAAqDC,gBAAmBC,GAAA,8GAAAC,KAAA,0pMAAuyMC,aAAsBL,MAAA,oDAAAM,KAAA,oBAAAC,aAAA,0BAA+HC,aAAgBC,KAAA","file":"path---2017-12-31-elm-intro-2d0df19cf43fb9f3344a.js","sourcesContent":["webpackJsonp([115028173322024],{\n\n/***/ 496:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"yerevancoder\",\"author\":\"Coders of Armenia\"}},\"markdownRemark\":{\"id\":\"/Users/Edgar/Repos/yerevan-coder/src/pages/2017-12-31-elm-intro/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<p><em>By Grigori Aramyan</em>,\\ncatch me on <a href='https://twitter.com/@griaram'>twitter</a></p>\\n<p>Elm is a strongly-typed functional programming language for frontend. It has simplicity and maintainability of functional programming paradigm in general, but exposes beauty of it’s own architecture as well. It’s a compiled language and compiler makes max efforts to ensure bug-free runtime code, which, on the other hand-side, means your code won’t compile, if there’s a mistype, use of undefined variable or similar stuff. Elm’s error messages are one of the “proud points” of Evan’s team though (creator of Elm, Evan Czaplicki). Compiler produces nice, human-readable messages with hints, pointing exactly to where/what is wrong with code, assisting devs as much as machines can probably do.</p>\\n<h2>The Elm Architecture</h2>\\n<p>Workflow of any Elm application is pretty straightforward: user fires a message (read event) by interacting with UI (text input, button click etc.), <code>update</code> function handles it by pattern matching on type of message and modifying model accordingly, <code>view</code> function re-renders UI using it’s virtual dom, so only minimal required render is performed. If you’re familiar with React/Redux, this architecture won’t be confusing. (Redux workflow was partially inspired by the elm architecture, according to Dan Abramov, author of Redux) Otherwise, it won’t be confusing after you play with it a bit. I made a simple todo app for this post, showing the very basics of Elm application, like module structure, code conventions, syntax, UI component styling, interop with JavaScript etc. You can find it under this repo: <a href=\\\"https://github.com/grigor-aramyan/todo-elm\\\">https://github.com/grigor-aramyan/todo-elm</a>. Read the Readme, it explains how you can run the app and make changes to elm code itself. I made a skeleton boilerplate of <code>Main.elm</code> as well, that can get you up-and-running in seconds. You can play with it also, or just copy/paste it’s content in every Main.elm of your projects (main Elm module, from which compiler starts running, is called <code>Main.elm</code>). Here’s the boilerplate gist: <a href=\\\"https://gist.github.com/grigor-aramyan/b29a6272f5656d9ddc56f591a3e03063\\\">https://gist.github.com/grigor-aramyan/b29a6272f5656d9ddc56f591a3e03063</a>.</p>\\n<p>Elm has it’s own REPL. You’ll get that after installing Elm on your local machine from official website <a href=\\\"http://elm-lang.org/\\\">http://elm-lang.org/</a>. After installing, type <code>elm</code> in shell to see what you’ve got.</p>\\n<h2>Type and type aliases</h2>\\n<p>You can define your own types in Elm.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>type Visualize =\\n    All\\n    | Completed\\n    | Active</code></pre>\\n      </div>\\n<p>This chunk defines “Visualize” type, which can have 3 values, either <code>All</code>, <code>Completed</code> or <code>Active</code>. One use case for custom types is dispatch events/messages - by having enum-like data, <code>update</code> function can precisely pattern match fired message and perform tasks accordingly. Also, it helps compiler to help us by warning, that not all possible type values are covered in <code>update</code>. Actually, it’s not warning us, it just won’t compile.</p>\\n<p>Type aliases make possible to combine primitive types into more complex structures.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>type alias TodoItem =\\n    { title : String\\n    , completed : Bool\\n    , id : Int\\n    }</code></pre>\\n      </div>\\n<p>The above chunk defines <code>TodoItem</code> custom type (read, record or object or class), that has 3 fields. Type aliases are often used to define application model structure. Here’s an example of it:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>type alias Model =\\n    { todoItems : List TodoItem\\n    , currentTodo : String\\n    , show : Visualize\\n    , currentIndex : Int\\n    }</code></pre>\\n      </div>\\n<h2>Interop, Encode/Decode</h2>\\n<p>Elm application can communicate with JavaScript modules through ports (and flags, actually, but ports are more flexible, so get to know them from the beggining). Elm is strongly typed language, JavaScript - is not, so there’s need of encoders and decoders, that will explain to JavaScript modules what particular Elm values mean and vice versa. Decoders have another major role - they want let data to pass through port and into Elm, if it doesn’t comply to type defined in decoder, so JavaScript side bugs will stay there only.</p>\\n<p>The above mentioned Todo application has Encoders/Decoders and interop with Javascript implemented, so you can check them at work. Also, (actually, in first place) look up the <code>Get Started</code> guide in Elm official website docs. For community discussions, join Elm’s page on Reddit: <a href=\\\"https://www.reddit.com/r/elm/\\\">https://www.reddit.com/r/elm/</a></p>\\n<h2>Partial function</h2>\\n<p>Maybe one of the most challenging parts in Elm application are type annotations. Here’s an example:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>update : Msg -> Model -> (Model, Cmd Msg)</code></pre>\\n      </div>\\n<p>It says, function “update” receives 2 parameters of types “Msg” and “Model”, then returns a type “Model, Cmd Msg”. Here’s the question - why arrows, instead of commas. And here’s the answer - because Elm has the idea of “partial functions” built within.</p>\\n<p>Example:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>someFunc : String -> Int -> Int -> Bool</code></pre>\\n      </div>\\n<p>If you give “someFunc” all 3 declared parameters, it will return a “Bool” type value. On the other hand, if you give it just “String”, it will return an anonymous function whith following type annotation <code>Int -> Int -> Bool</code> (the former “String” is excluded, because it’s matched already with one-parameter function call). That’s the reason why there is no clear separation of function arguments and it’s return value - argument values can become return values, if partial functions are in play.</p>\\n<p>Hope this post will help to get some feel of Elm beauty.</p>\\n<p>Happy hacking ;)</p>\",\"frontmatter\":{\"title\":\"Elm, beauty of functional programming to frontend\",\"date\":\"December 31, 2017\",\"discussionId\":\"2017-12-31-elm-intro\"}}},\"pathContext\":{\"slug\":\"/2017-12-31-elm-intro/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---2017-12-31-elm-intro-2d0df19cf43fb9f3344a.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"yerevancoder\",\"author\":\"Coders of Armenia\"}},\"markdownRemark\":{\"id\":\"/Users/Edgar/Repos/yerevan-coder/src/pages/2017-12-31-elm-intro/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<p><em>By Grigori Aramyan</em>,\\ncatch me on <a href='https://twitter.com/@griaram'>twitter</a></p>\\n<p>Elm is a strongly-typed functional programming language for frontend. It has simplicity and maintainability of functional programming paradigm in general, but exposes beauty of it’s own architecture as well. It’s a compiled language and compiler makes max efforts to ensure bug-free runtime code, which, on the other hand-side, means your code won’t compile, if there’s a mistype, use of undefined variable or similar stuff. Elm’s error messages are one of the “proud points” of Evan’s team though (creator of Elm, Evan Czaplicki). Compiler produces nice, human-readable messages with hints, pointing exactly to where/what is wrong with code, assisting devs as much as machines can probably do.</p>\\n<h2>The Elm Architecture</h2>\\n<p>Workflow of any Elm application is pretty straightforward: user fires a message (read event) by interacting with UI (text input, button click etc.), <code>update</code> function handles it by pattern matching on type of message and modifying model accordingly, <code>view</code> function re-renders UI using it’s virtual dom, so only minimal required render is performed. If you’re familiar with React/Redux, this architecture won’t be confusing. (Redux workflow was partially inspired by the elm architecture, according to Dan Abramov, author of Redux) Otherwise, it won’t be confusing after you play with it a bit. I made a simple todo app for this post, showing the very basics of Elm application, like module structure, code conventions, syntax, UI component styling, interop with JavaScript etc. You can find it under this repo: <a href=\\\"https://github.com/grigor-aramyan/todo-elm\\\">https://github.com/grigor-aramyan/todo-elm</a>. Read the Readme, it explains how you can run the app and make changes to elm code itself. I made a skeleton boilerplate of <code>Main.elm</code> as well, that can get you up-and-running in seconds. You can play with it also, or just copy/paste it’s content in every Main.elm of your projects (main Elm module, from which compiler starts running, is called <code>Main.elm</code>). Here’s the boilerplate gist: <a href=\\\"https://gist.github.com/grigor-aramyan/b29a6272f5656d9ddc56f591a3e03063\\\">https://gist.github.com/grigor-aramyan/b29a6272f5656d9ddc56f591a3e03063</a>.</p>\\n<p>Elm has it’s own REPL. You’ll get that after installing Elm on your local machine from official website <a href=\\\"http://elm-lang.org/\\\">http://elm-lang.org/</a>. After installing, type <code>elm</code> in shell to see what you’ve got.</p>\\n<h2>Type and type aliases</h2>\\n<p>You can define your own types in Elm.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>type Visualize =\\n    All\\n    | Completed\\n    | Active</code></pre>\\n      </div>\\n<p>This chunk defines “Visualize” type, which can have 3 values, either <code>All</code>, <code>Completed</code> or <code>Active</code>. One use case for custom types is dispatch events/messages - by having enum-like data, <code>update</code> function can precisely pattern match fired message and perform tasks accordingly. Also, it helps compiler to help us by warning, that not all possible type values are covered in <code>update</code>. Actually, it’s not warning us, it just won’t compile.</p>\\n<p>Type aliases make possible to combine primitive types into more complex structures.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>type alias TodoItem =\\n    { title : String\\n    , completed : Bool\\n    , id : Int\\n    }</code></pre>\\n      </div>\\n<p>The above chunk defines <code>TodoItem</code> custom type (read, record or object or class), that has 3 fields. Type aliases are often used to define application model structure. Here’s an example of it:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>type alias Model =\\n    { todoItems : List TodoItem\\n    , currentTodo : String\\n    , show : Visualize\\n    , currentIndex : Int\\n    }</code></pre>\\n      </div>\\n<h2>Interop, Encode/Decode</h2>\\n<p>Elm application can communicate with JavaScript modules through ports (and flags, actually, but ports are more flexible, so get to know them from the beggining). Elm is strongly typed language, JavaScript - is not, so there’s need of encoders and decoders, that will explain to JavaScript modules what particular Elm values mean and vice versa. Decoders have another major role - they want let data to pass through port and into Elm, if it doesn’t comply to type defined in decoder, so JavaScript side bugs will stay there only.</p>\\n<p>The above mentioned Todo application has Encoders/Decoders and interop with Javascript implemented, so you can check them at work. Also, (actually, in first place) look up the <code>Get Started</code> guide in Elm official website docs. For community discussions, join Elm’s page on Reddit: <a href=\\\"https://www.reddit.com/r/elm/\\\">https://www.reddit.com/r/elm/</a></p>\\n<h2>Partial function</h2>\\n<p>Maybe one of the most challenging parts in Elm application are type annotations. Here’s an example:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>update : Msg -> Model -> (Model, Cmd Msg)</code></pre>\\n      </div>\\n<p>It says, function “update” receives 2 parameters of types “Msg” and “Model”, then returns a type “Model, Cmd Msg”. Here’s the question - why arrows, instead of commas. And here’s the answer - because Elm has the idea of “partial functions” built within.</p>\\n<p>Example:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>someFunc : String -> Int -> Int -> Bool</code></pre>\\n      </div>\\n<p>If you give “someFunc” all 3 declared parameters, it will return a “Bool” type value. On the other hand, if you give it just “String”, it will return an anonymous function whith following type annotation <code>Int -> Int -> Bool</code> (the former “String” is excluded, because it’s matched already with one-parameter function call). That’s the reason why there is no clear separation of function arguments and it’s return value - argument values can become return values, if partial functions are in play.</p>\\n<p>Hope this post will help to get some feel of Elm beauty.</p>\\n<p>Happy hacking ;)</p>\",\"frontmatter\":{\"title\":\"Elm, beauty of functional programming to frontend\",\"date\":\"December 31, 2017\",\"discussionId\":\"2017-12-31-elm-intro\"}}},\"pathContext\":{\"slug\":\"/2017-12-31-elm-intro/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/2017-12-31-elm-intro.json\n// module id = 496\n// module chunks = 115028173322024"],"sourceRoot":""}