webpackJsonp([0xdd6e472c0dfa],{520:function(e,o){e.exports={data:{site:{siteMetadata:{title:"yerevancoder",author:"Coders of Armenia"}},markdownRemark:{id:"/Users/edgarkhanzadian/Documents/yerevancoder.github.io/src/pages/2018-03-04-js-function-declaration-and-function-expression/index.md absPath of file >>> MarkdownRemark",html:'<h1>Function declaration and Function expression</h1>\n<h2>Function declaration vs Function expression</h2>\n<p>As we know there are couple of ways to create functions in Javascript: you can store function in variable and declare it directly. The former is known as function expression and the latter is known as function declaration. First, let’s take a look at function expression.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js="><code>const a = function() {\n    //...do something\n}</code></pre>\n      </div>\n<p>So we create a <code>const</code>, give it a name <code>a</code>, and afterwards can call the function by calling <code>a()</code>. Works as we expected, we create something, and can use that afterwards. And what about function expressions. Consider the following piece of code.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js="><code>function greet(name) {\n    console.log(\'Hello, \' + name)\n}</code></pre>\n      </div>\n<p>Here we cerate a <code>greet</code> function which outputs <code>Hello</code> and the argument we pass to it. However, something strange happens when we call the greet function before it is declared.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js="><code>greet(\'void\'); // Outputs `Hello, void`\nfunction greet(name) {\n    console.log(\'Hello, \' + name)\n}</code></pre>\n      </div>\n<p>It just works. Why? Doesn’t javascript read programs line by line, and shouldn’t it throw an error ? Well, not actually. Javascript engines and their execution process is quiet complicated, and to understand why the very mentioned happens, we should get acquainted with a new concept, called <code>Hoisting</code>.</p>\n<h2>Hoisting</h2>\n<p>To understand hoisting we should first understand how the piece of code we write in Javascript is executed. As already mentioned, it is not a trivial process, and to dumb it up, consists of two general parts. First the piece of code that we wrote is “compiled” (not really), and then interpreted. For example here.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js="><code>a = 2;\nvar a;\n\nconsole.log( a ) //logs 2;</code></pre>\n      </div>\n<p>Here is how the above code outputs 2 and not undefined when <code>var a</code> is redeclared on the second line. First our program “compiles” the code, and declares known variables, in this case some <code>var a</code>, after, during interpretation it looks for value assignments and assigns <code>2</code> to it’s already known <code>var a</code>. So the declaration <code>var a</code> comes befor the assignment of <code>2</code>. Same is with the function declarations. However, the hoisting noly affects the same scope, that is, it is immpossible to access the declared function outside of the scope.\nIt is important to remember, that only function declarations are hoisted. Let’s take a look at the following piece of code:</p>\n<div class="gatsby-highlight">\n      <pre class="language-js="><code>someFunc(); // TypeError!\n\nvar someFunc = function () {\n\t//...\n};</code></pre>\n      </div>\n<p>Here we can see, that the program doesn’t throw a <code>ReferenceError</code>; but instead it throws a <code>TypeError</code>, saying that <code>someFunc is not a function</code>.\nThis happens for the following reason. The <code>compiler</code> initializes <code>someFunc</code> as a variable, and, because there are no other declarations, engine starts interpreting the program, when it gets to the first line, it sees <code>someFunc</code> being called as a function, however, it sees <code>someFunc</code> initialized as a variable, and not a function.</p>\n<h2>Summary</h2>\n<p>You would think, that we should be really carefull while writing declaring functions or variables in JS. While it’s mostly true, in the development you wouldn’t be using <code>var</code>, but <code>let</code> and <code>const</code>, which are block scoped and were introduced in ES6. <a href="http://javascriptkit.com/javatutors/javascript-es6-let-const.shtml">http://javascriptkit.com/javatutors/javascript-es6-let-const.shtml</a>). Also, if for some bizzare reasons you need to write ES5, then <code>"use strict"</code> comes to help (<a href="https://johnresig.com/blog/ecmascript-5-strict-mode-json-and-more/">https://johnresig.com/blog/ecmascript-5-strict-mode-json-and-more/</a>).</p>',frontmatter:{title:"",date:null,discussionId:null}}},pathContext:{slug:"/2018-03-04-js-function-declaration-and-function-expression/"}}}});
//# sourceMappingURL=path---2018-03-04-js-function-declaration-and-function-expression-61a76cd8d01a03399d0d.js.map